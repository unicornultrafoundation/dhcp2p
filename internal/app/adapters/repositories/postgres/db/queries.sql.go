// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const allocateNextTokenID = `-- name: AllocateNextTokenID :one
UPDATE alloc_state
SET last_token_id = (last_token_id - 1)
WHERE id = 1
RETURNING last_token_id
`

func (q *Queries) AllocateNextTokenID(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, allocateNextTokenID)
	var last_token_id int64
	err := row.Scan(&last_token_id)
	return last_token_id, err
}

const consumeNonce = `-- name: ConsumeNonce :one
UPDATE nonces
SET used = true, used_at = now()
WHERE id = $1 AND peer_id = $2 AND used = false AND expires_at > now()
RETURNING id, peer_id, issued_at, expires_at, used, used_at
`

type ConsumeNonceParams struct {
	ID     pgtype.UUID
	PeerID string
}

func (q *Queries) ConsumeNonce(ctx context.Context, arg ConsumeNonceParams) (Nonce, error) {
	row := q.db.QueryRow(ctx, consumeNonce, arg.ID, arg.PeerID)
	var i Nonce
	err := row.Scan(
		&i.ID,
		&i.PeerID,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.Used,
		&i.UsedAt,
	)
	return i, err
}

const createNonce = `-- name: CreateNonce :one
INSERT INTO nonces (peer_id, issued_at, expires_at) 
VALUES ($1, now(), now() + ($2::int * interval '1 minute')) 
RETURNING id, peer_id, issued_at, expires_at, used, used_at
`

type CreateNonceParams struct {
	PeerID string
	Ttl    int32
}

func (q *Queries) CreateNonce(ctx context.Context, arg CreateNonceParams) (Nonce, error) {
	row := q.db.QueryRow(ctx, createNonce, arg.PeerID, arg.Ttl)
	var i Nonce
	err := row.Scan(
		&i.ID,
		&i.PeerID,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.Used,
		&i.UsedAt,
	)
	return i, err
}

const deleteExpiredNonces = `-- name: DeleteExpiredNonces :exec
DELETE FROM nonces WHERE expires_at < now()
`

func (q *Queries) DeleteExpiredNonces(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredNonces)
	return err
}

const findExpiredLeaseForReuse = `-- name: FindExpiredLeaseForReuse :one
SELECT token_id, peer_id, expires_at, created_at, updated_at, EXTRACT(EPOCH FROM (expires_at - now()))::int AS ttl
FROM leases
WHERE expires_at < now()
ORDER BY expires_at ASC
LIMIT 1
FOR UPDATE SKIP LOCKED
`

type FindExpiredLeaseForReuseRow struct {
	TokenID   int64
	PeerID    string
	ExpiresAt pgtype.Timestamptz
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Ttl       int32
}

func (q *Queries) FindExpiredLeaseForReuse(ctx context.Context) (FindExpiredLeaseForReuseRow, error) {
	row := q.db.QueryRow(ctx, findExpiredLeaseForReuse)
	var i FindExpiredLeaseForReuseRow
	err := row.Scan(
		&i.TokenID,
		&i.PeerID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Ttl,
	)
	return i, err
}

const getLeaseByPeerID = `-- name: GetLeaseByPeerID :one
SELECT token_id, peer_id, expires_at, created_at, updated_at, EXTRACT(EPOCH FROM (expires_at - now()))::int AS ttl
FROM leases
WHERE peer_id = $1 AND expires_at > now()
`

type GetLeaseByPeerIDRow struct {
	TokenID   int64
	PeerID    string
	ExpiresAt pgtype.Timestamptz
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Ttl       int32
}

func (q *Queries) GetLeaseByPeerID(ctx context.Context, peerID string) (GetLeaseByPeerIDRow, error) {
	row := q.db.QueryRow(ctx, getLeaseByPeerID, peerID)
	var i GetLeaseByPeerIDRow
	err := row.Scan(
		&i.TokenID,
		&i.PeerID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Ttl,
	)
	return i, err
}

const getLeaseByTokenID = `-- name: GetLeaseByTokenID :one
SELECT token_id, peer_id, expires_at, created_at, updated_at, EXTRACT(EPOCH FROM (expires_at - now()))::int AS ttl
FROM leases
WHERE token_id = $1 AND expires_at > now()
`

type GetLeaseByTokenIDRow struct {
	TokenID   int64
	PeerID    string
	ExpiresAt pgtype.Timestamptz
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Ttl       int32
}

func (q *Queries) GetLeaseByTokenID(ctx context.Context, tokenID int64) (GetLeaseByTokenIDRow, error) {
	row := q.db.QueryRow(ctx, getLeaseByTokenID, tokenID)
	var i GetLeaseByTokenIDRow
	err := row.Scan(
		&i.TokenID,
		&i.PeerID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Ttl,
	)
	return i, err
}

const getNonce = `-- name: GetNonce :one
SELECT id, peer_id, issued_at, expires_at, used, used_at FROM nonces 
WHERE id = $1 AND expires_at > now() AND used = false
`

func (q *Queries) GetNonce(ctx context.Context, id pgtype.UUID) (Nonce, error) {
	row := q.db.QueryRow(ctx, getNonce, id)
	var i Nonce
	err := row.Scan(
		&i.ID,
		&i.PeerID,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.Used,
		&i.UsedAt,
	)
	return i, err
}

const insertLease = `-- name: InsertLease :one
INSERT INTO leases (token_id, peer_id, expires_at, created_at, updated_at)
VALUES ($1, $2, now() + ($3::int * interval '1 minute'), now(), now())
RETURNING token_id, peer_id, expires_at, created_at, updated_at, EXTRACT(EPOCH FROM (expires_at - now()))::int AS ttl
`

type InsertLeaseParams struct {
	TokenID int64
	PeerID  string
	Ttl     int32
}

type InsertLeaseRow struct {
	TokenID   int64
	PeerID    string
	ExpiresAt pgtype.Timestamptz
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Ttl       int32
}

func (q *Queries) InsertLease(ctx context.Context, arg InsertLeaseParams) (InsertLeaseRow, error) {
	row := q.db.QueryRow(ctx, insertLease, arg.TokenID, arg.PeerID, arg.Ttl)
	var i InsertLeaseRow
	err := row.Scan(
		&i.TokenID,
		&i.PeerID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Ttl,
	)
	return i, err
}

const releaseLease = `-- name: ReleaseLease :exec
UPDATE leases
SET expires_at = now()
WHERE token_id = $1 AND peer_id = $2
`

type ReleaseLeaseParams struct {
	TokenID int64
	PeerID  string
}

func (q *Queries) ReleaseLease(ctx context.Context, arg ReleaseLeaseParams) error {
	_, err := q.db.Exec(ctx, releaseLease, arg.TokenID, arg.PeerID)
	return err
}

const renewLease = `-- name: RenewLease :one
UPDATE leases
SET expires_at = now() + ($3::int * interval '1 minute'),
    updated_at = now()
WHERE token_id = $1 AND peer_id = $2 AND expires_at > now()
RETURNING token_id, peer_id, expires_at, created_at, updated_at, EXTRACT(EPOCH FROM (expires_at - now()))::int AS ttl
`

type RenewLeaseParams struct {
	TokenID int64
	PeerID  string
	Ttl     int32
}

type RenewLeaseRow struct {
	TokenID   int64
	PeerID    string
	ExpiresAt pgtype.Timestamptz
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Ttl       int32
}

func (q *Queries) RenewLease(ctx context.Context, arg RenewLeaseParams) (RenewLeaseRow, error) {
	row := q.db.QueryRow(ctx, renewLease, arg.TokenID, arg.PeerID, arg.Ttl)
	var i RenewLeaseRow
	err := row.Scan(
		&i.TokenID,
		&i.PeerID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Ttl,
	)
	return i, err
}

const reuseLease = `-- name: ReuseLease :one
UPDATE leases
SET peer_id = $1,
    expires_at = now() + ($3::int * interval '1 minute'),
    updated_at = now()
WHERE token_id = $2
RETURNING token_id, peer_id, expires_at, created_at, updated_at, EXTRACT(EPOCH FROM (expires_at - now()))::int AS ttl
`

type ReuseLeaseParams struct {
	PeerID  string
	TokenID int64
	Ttl     int32
}

type ReuseLeaseRow struct {
	TokenID   int64
	PeerID    string
	ExpiresAt pgtype.Timestamptz
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Ttl       int32
}

func (q *Queries) ReuseLease(ctx context.Context, arg ReuseLeaseParams) (ReuseLeaseRow, error) {
	row := q.db.QueryRow(ctx, reuseLease, arg.PeerID, arg.TokenID, arg.Ttl)
	var i ReuseLeaseRow
	err := row.Scan(
		&i.TokenID,
		&i.PeerID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Ttl,
	)
	return i, err
}
